{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Directive, EventEmitter, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport { Subject, Observable, ReplaySubject, merge, combineLatest, fromEvent } from 'rxjs';\nimport { filter, mergeMap, startWith, map, share, takeUntil, take, takeLast, count, pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\n\nfunction addClass(renderer, element, classToAdd) {\n  if (classToAdd) {\n    classToAdd.split(' ').forEach(className => renderer.addClass(element.nativeElement, className));\n  }\n}\n\nfunction removeClass(renderer, element, classToRemove) {\n  if (classToRemove) {\n    classToRemove.split(' ').forEach(className => renderer.removeClass(element.nativeElement, className));\n  }\n}\n\nclass DraggableHelper {\n  constructor() {\n    this.currentDrag = new Subject();\n  }\n\n}\n\nDraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n  return new (t || DraggableHelper)();\n};\n\nDraggableHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DraggableHelper,\n  factory: DraggableHelper.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableHelper, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\n\n\nclass DraggableScrollContainerDirective {\n  /**\n   * @hidden\n   */\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n  }\n\n}\n\nDraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n  return new (t || DraggableScrollContainerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nDraggableScrollContainerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DraggableScrollContainerDirective,\n  selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableScrollContainerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggableScrollContainer]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }];\n  }, null);\n})();\n\nclass DraggableDirective {\n  /**\n   * @hidden\n   */\n  constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n    this.element = element;\n    this.renderer = renderer;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.vcr = vcr;\n    this.scrollContainer = scrollContainer;\n    this.document = document;\n    /**\n     * The axis along which the element is draggable\n     */\n\n    this.dragAxis = {\n      x: true,\n      y: true\n    };\n    /**\n     * Snap all drags to an x / y grid\n     */\n\n    this.dragSnapGrid = {};\n    /**\n     * Show a ghost element that shows the drag when dragging\n     */\n\n    this.ghostDragEnabled = true;\n    /**\n     * Show the original element when ghostDragEnabled is true\n     */\n\n    this.showOriginalElementWhileDragging = false;\n    /**\n     * The cursor to use when hovering over a draggable element\n     */\n\n    this.dragCursor = '';\n    /*\n     * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n     */\n\n    this.autoScroll = {\n      margin: 20\n    };\n    /**\n     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n     */\n\n    this.dragPointerDown = new EventEmitter();\n    /**\n     * Called when the element has started to be dragged.\n     * Only called after at least one mouse or touch move event.\n     * If you call $event.cancelDrag$.emit() it will cancel the current drag\n     */\n\n    this.dragStart = new EventEmitter();\n    /**\n     * Called after the ghost element has been created\n     */\n\n    this.ghostElementCreated = new EventEmitter();\n    /**\n     * Called when the element is being dragged\n     */\n\n    this.dragging = new EventEmitter();\n    /**\n     * Called after the element is dragged\n     */\n\n    this.dragEnd = new EventEmitter();\n    /**\n     * @hidden\n     */\n\n    this.pointerDown$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerMove$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerUp$ = new Subject();\n    this.eventListenerSubscriptions = {};\n    this.destroy$ = new Subject();\n    this.timeLongPress = {\n      timerBegin: 0,\n      timerEnd: 0\n    };\n  }\n\n  ngOnInit() {\n    this.checkEventListeners();\n    const pointerDragged$ = this.pointerDown$.pipe(filter(() => this.canDrag()), mergeMap(pointerDownEvent => {\n      // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n      // stop mouse events propagating up the chain\n      if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n        pointerDownEvent.event.stopPropagation();\n      } // hack to prevent text getting selected in safari while dragging\n\n\n      const globalDragStyle = this.renderer.createElement('style');\n      this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n      this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n      requestAnimationFrame(() => {\n        this.document.head.appendChild(globalDragStyle);\n      });\n      const startScrollPosition = this.getScrollPosition();\n      const scrollContainerScroll$ = new Observable(observer => {\n        const scrollContainer = this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window';\n        return this.renderer.listen(scrollContainer, 'scroll', e => observer.next(e));\n      }).pipe(startWith(startScrollPosition), map(() => this.getScrollPosition()));\n      const currentDrag$ = new Subject();\n      const cancelDrag$ = new ReplaySubject();\n\n      if (this.dragPointerDown.observers.length > 0) {\n        this.zone.run(() => {\n          this.dragPointerDown.next({\n            x: 0,\n            y: 0\n          });\n        });\n      }\n\n      const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n      const pointerMove = combineLatest([this.pointerMove$, scrollContainerScroll$]).pipe(map(([pointerMoveEvent, scroll]) => {\n        return {\n          currentDrag$,\n          transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n          transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n          clientX: pointerMoveEvent.clientX,\n          clientY: pointerMoveEvent.clientY,\n          scrollLeft: scroll.left,\n          scrollTop: scroll.top,\n          target: pointerMoveEvent.event.target\n        };\n      }), map(moveData => {\n        if (this.dragSnapGrid.x) {\n          moveData.transformX = Math.round(moveData.transformX / this.dragSnapGrid.x) * this.dragSnapGrid.x;\n        }\n\n        if (this.dragSnapGrid.y) {\n          moveData.transformY = Math.round(moveData.transformY / this.dragSnapGrid.y) * this.dragSnapGrid.y;\n        }\n\n        return moveData;\n      }), map(moveData => {\n        if (!this.dragAxis.x) {\n          moveData.transformX = 0;\n        }\n\n        if (!this.dragAxis.y) {\n          moveData.transformY = 0;\n        }\n\n        return moveData;\n      }), map(moveData => {\n        const scrollX = moveData.scrollLeft - startScrollPosition.left;\n        const scrollY = moveData.scrollTop - startScrollPosition.top;\n        return Object.assign(Object.assign({}, moveData), {\n          x: moveData.transformX + scrollX,\n          y: moveData.transformY + scrollY\n        });\n      }), filter(({\n        x,\n        y,\n        transformX,\n        transformY\n      }) => !this.validateDrag || this.validateDrag({\n        x,\n        y,\n        transform: {\n          x: transformX,\n          y: transformY\n        }\n      })), takeUntil(dragComplete$), share());\n      const dragStarted$ = pointerMove.pipe(take(1), share());\n      const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n      dragStarted$.subscribe(({\n        clientX,\n        clientY,\n        x,\n        y\n      }) => {\n        if (this.dragStart.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragStart.next({\n              cancelDrag$\n            });\n          });\n        }\n\n        this.scroller = autoScroll([this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : this.document.defaultView], Object.assign(Object.assign({}, this.autoScroll), {\n          autoScroll() {\n            return true;\n          }\n\n        }));\n        addClass(this.renderer, this.element, this.dragActiveClass);\n\n        if (this.ghostDragEnabled) {\n          const rect = this.element.nativeElement.getBoundingClientRect();\n          const clone = this.element.nativeElement.cloneNode(true);\n\n          if (!this.showOriginalElementWhileDragging) {\n            this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n          }\n\n          if (this.ghostElementAppendTo) {\n            this.ghostElementAppendTo.appendChild(clone);\n          } else {\n            this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);\n          }\n\n          this.ghostElement = clone;\n          this.document.body.style.cursor = this.dragCursor;\n          this.setElementStyles(clone, {\n            position: 'fixed',\n            top: `${rect.top}px`,\n            left: `${rect.left}px`,\n            width: `${rect.width}px`,\n            height: `${rect.height}px`,\n            cursor: this.dragCursor,\n            margin: '0',\n            willChange: 'transform',\n            pointerEvents: 'none'\n          });\n\n          if (this.ghostElementTemplate) {\n            const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n            clone.innerHTML = '';\n            viewRef.rootNodes.filter(node => node instanceof Node).forEach(node => {\n              clone.appendChild(node);\n            });\n            dragEnded$.subscribe(() => {\n              this.vcr.remove(this.vcr.indexOf(viewRef));\n            });\n          }\n\n          if (this.ghostElementCreated.observers.length > 0) {\n            this.zone.run(() => {\n              this.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone\n              });\n            });\n          }\n\n          dragEnded$.subscribe(() => {\n            clone.parentElement.removeChild(clone);\n            this.ghostElement = null;\n            this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n          });\n        }\n\n        this.draggableHelper.currentDrag.next(currentDrag$);\n      });\n      dragEnded$.pipe(mergeMap(dragEndData => {\n        const dragEndData$ = cancelDrag$.pipe(count(), take(1), map(calledCount => Object.assign(Object.assign({}, dragEndData), {\n          dragCancelled: calledCount > 0\n        })));\n        cancelDrag$.complete();\n        return dragEndData$;\n      })).subscribe(({\n        x,\n        y,\n        dragCancelled\n      }) => {\n        this.scroller.destroy();\n\n        if (this.dragEnd.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragEnd.next({\n              x,\n              y,\n              dragCancelled\n            });\n          });\n        }\n\n        removeClass(this.renderer, this.element, this.dragActiveClass);\n        currentDrag$.complete();\n      });\n      merge(dragComplete$, dragEnded$).pipe(take(1)).subscribe(() => {\n        requestAnimationFrame(() => {\n          this.document.head.removeChild(globalDragStyle);\n        });\n      });\n      return pointerMove;\n    }), share());\n    merge(pointerDragged$.pipe(take(1), map(value => [, value])), pointerDragged$.pipe(pairwise())).pipe(filter(([previous, next]) => {\n      if (!previous) {\n        return true;\n      }\n\n      return previous.x !== next.x || previous.y !== next.y;\n    }), map(([previous, next]) => next)).subscribe(({\n      x,\n      y,\n      currentDrag$,\n      clientX,\n      clientY,\n      transformX,\n      transformY,\n      target\n    }) => {\n      if (this.dragging.observers.length > 0) {\n        this.zone.run(() => {\n          this.dragging.next({\n            x,\n            y\n          });\n        });\n      }\n\n      requestAnimationFrame(() => {\n        if (this.ghostElement) {\n          const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n          this.setElementStyles(this.ghostElement, {\n            transform,\n            '-webkit-transform': transform,\n            '-ms-transform': transform,\n            '-moz-transform': transform,\n            '-o-transform': transform\n          });\n        }\n      });\n      currentDrag$.next({\n        clientX,\n        clientY,\n        dropData: this.dropData,\n        target\n      });\n    });\n  }\n\n  ngOnChanges(changes) {\n    if (changes.dragAxis) {\n      this.checkEventListeners();\n    }\n  }\n\n  ngOnDestroy() {\n    this.unsubscribeEventListeners();\n    this.pointerDown$.complete();\n    this.pointerMove$.complete();\n    this.pointerUp$.complete();\n    this.destroy$.next();\n  }\n\n  checkEventListeners() {\n    const canDrag = this.canDrag();\n    const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown', event => {\n          this.onMouseDown(event);\n        });\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup', event => {\n          this.onMouseUp(event);\n        });\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart', event => {\n          this.onTouchStart(event);\n        });\n        this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend', event => {\n          this.onTouchEnd(event);\n        });\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel', event => {\n          this.onTouchEnd(event);\n        });\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter', () => {\n          this.onMouseEnter();\n        });\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave', () => {\n          this.onMouseLeave();\n        });\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n\n  onMouseDown(event) {\n    if (event.button === 0) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', mouseMoveEvent => {\n          this.pointerMove$.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        });\n      }\n\n      this.pointerDown$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n  }\n\n  onMouseUp(event) {\n    if (event.button === 0) {\n      if (this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove();\n        delete this.eventListenerSubscriptions.mousemove;\n      }\n\n      this.pointerUp$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n  }\n\n  onTouchStart(event) {\n    let startScrollPosition;\n    let isDragActivated;\n    let hasContainerScrollbar;\n\n    if (this.touchStartLongPress) {\n      this.timeLongPress.timerBegin = Date.now();\n      isDragActivated = false;\n      hasContainerScrollbar = this.hasScrollbar();\n      startScrollPosition = this.getScrollPosition();\n    }\n\n    if (!this.eventListenerSubscriptions.touchmove) {\n      const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe(e => {\n        e.preventDefault();\n      });\n      const touchMoveListener = fromEvent(this.document, 'touchmove', {\n        passive: false\n      }).subscribe(touchMoveEvent => {\n        if (this.touchStartLongPress && !isDragActivated && hasContainerScrollbar) {\n          isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n        }\n\n        if (!this.touchStartLongPress || !hasContainerScrollbar || isDragActivated) {\n          touchMoveEvent.preventDefault();\n          this.pointerMove$.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY\n          });\n        }\n      });\n\n      this.eventListenerSubscriptions.touchmove = () => {\n        contextMenuListener.unsubscribe();\n        touchMoveListener.unsubscribe();\n      };\n    }\n\n    this.pointerDown$.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    });\n  }\n\n  onTouchEnd(event) {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n\n      if (this.touchStartLongPress) {\n        this.enableScroll();\n      }\n    }\n\n    this.pointerUp$.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    });\n  }\n\n  onMouseEnter() {\n    this.setCursor(this.dragCursor);\n  }\n\n  onMouseLeave() {\n    this.setCursor('');\n  }\n\n  canDrag() {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n\n  setCursor(value) {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n    }\n  }\n\n  unsubscribeEventListeners() {\n    Object.keys(this.eventListenerSubscriptions).forEach(type => {\n      this.eventListenerSubscriptions[type]();\n      delete this.eventListenerSubscriptions[type];\n    });\n  }\n\n  setElementStyles(element, styles) {\n    Object.keys(styles).forEach(key => {\n      this.renderer.setStyle(element, key, styles[key]);\n    });\n  }\n\n  getScrollElement() {\n    if (this.scrollContainer) {\n      return this.scrollContainer.elementRef.nativeElement;\n    } else {\n      return this.document.body;\n    }\n  }\n\n  getScrollPosition() {\n    if (this.scrollContainer) {\n      return {\n        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n        left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n      };\n    } else {\n      return {\n        top: window.pageYOffset || this.document.documentElement.scrollTop,\n        left: window.pageXOffset || this.document.documentElement.scrollLeft\n      };\n    }\n  }\n\n  shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n    const moveScrollPosition = this.getScrollPosition();\n    const deltaScroll = {\n      top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n      left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n    };\n    const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n    const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n    const deltaTotal = deltaX + deltaY;\n    const longPressConfig = this.touchStartLongPress;\n\n    if (deltaTotal > longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n      this.timeLongPress.timerBegin = Date.now();\n    }\n\n    this.timeLongPress.timerEnd = Date.now();\n    const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\n    if (duration >= longPressConfig.delay) {\n      this.disableScroll();\n      return true;\n    }\n\n    return false;\n  }\n\n  enableScroll() {\n    if (this.scrollContainer) {\n      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n    }\n\n    this.renderer.setStyle(this.document.body, 'overflow', '');\n  }\n\n  disableScroll() {\n    /* istanbul ignore next */\n    if (this.scrollContainer) {\n      this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n    }\n\n    this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n  }\n\n  hasScrollbar() {\n    const scrollContainer = this.getScrollElement();\n    const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n    const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n    return containerHasHorizontalScroll || containerHasVerticalScroll;\n  }\n\n}\n\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n  return new (t || DraggableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DraggableHelper), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), i0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nDraggableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DraggableDirective,\n  selectors: [[\"\", \"mwlDraggable\", \"\"]],\n  inputs: {\n    dropData: \"dropData\",\n    dragAxis: \"dragAxis\",\n    dragSnapGrid: \"dragSnapGrid\",\n    ghostDragEnabled: \"ghostDragEnabled\",\n    showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n    validateDrag: \"validateDrag\",\n    dragCursor: \"dragCursor\",\n    dragActiveClass: \"dragActiveClass\",\n    ghostElementAppendTo: \"ghostElementAppendTo\",\n    ghostElementTemplate: \"ghostElementTemplate\",\n    touchStartLongPress: \"touchStartLongPress\",\n    autoScroll: \"autoScroll\"\n  },\n  outputs: {\n    dragPointerDown: \"dragPointerDown\",\n    dragStart: \"dragStart\",\n    ghostElementCreated: \"ghostElementCreated\",\n    dragging: \"dragging\",\n    dragEnd: \"dragEnd\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggable]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: DraggableHelper\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.ViewContainerRef\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, {\n    dropData: [{\n      type: Input\n    }],\n    dragAxis: [{\n      type: Input\n    }],\n    dragSnapGrid: [{\n      type: Input\n    }],\n    ghostDragEnabled: [{\n      type: Input\n    }],\n    showOriginalElementWhileDragging: [{\n      type: Input\n    }],\n    validateDrag: [{\n      type: Input\n    }],\n    dragCursor: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    ghostElementAppendTo: [{\n      type: Input\n    }],\n    ghostElementTemplate: [{\n      type: Input\n    }],\n    touchStartLongPress: [{\n      type: Input\n    }],\n    autoScroll: [{\n      type: Input\n    }],\n    dragPointerDown: [{\n      type: Output\n    }],\n    dragStart: [{\n      type: Output\n    }],\n    ghostElementCreated: [{\n      type: Output\n    }],\n    dragging: [{\n      type: Output\n    }],\n    dragEnd: [{\n      type: Output\n    }]\n  });\n})();\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nclass DroppableDirective {\n  constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n    this.element = element;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.renderer = renderer;\n    this.scrollContainer = scrollContainer;\n    /**\n     * Called when a draggable element starts overlapping the element\n     */\n\n    this.dragEnter = new EventEmitter();\n    /**\n     * Called when a draggable element stops overlapping the element\n     */\n\n    this.dragLeave = new EventEmitter();\n    /**\n     * Called when a draggable element is moved over the element\n     */\n\n    this.dragOver = new EventEmitter();\n    /**\n     * Called when a draggable element is dropped on this element\n     */\n\n    this.drop = new EventEmitter(); // eslint-disable-line  @angular-eslint/no-output-native\n  }\n\n  ngOnInit() {\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(drag$ => {\n      addClass(this.renderer, this.element, this.dragActiveClass);\n      const droppableElement = {\n        updateCache: true\n      };\n      const deregisterScrollListener = this.renderer.listen(this.scrollContainer ? this.scrollContainer.elementRef.nativeElement : 'window', 'scroll', () => {\n        droppableElement.updateCache = true;\n      });\n      let currentDragEvent;\n      const overlaps$ = drag$.pipe(map(({\n        clientX,\n        clientY,\n        dropData,\n        target\n      }) => {\n        currentDragEvent = {\n          clientX,\n          clientY,\n          dropData,\n          target\n        };\n\n        if (droppableElement.updateCache) {\n          droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n\n          if (this.scrollContainer) {\n            droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n          }\n\n          droppableElement.updateCache = false;\n        }\n\n        const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);\n        const isDropAllowed = !this.validateDrop || this.validateDrop({\n          clientX,\n          clientY,\n          target,\n          dropData\n        });\n\n        if (droppableElement.scrollContainerRect) {\n          return isWithinElement && isDropAllowed && isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect);\n        } else {\n          return isWithinElement && isDropAllowed;\n        }\n      }));\n      const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n      let dragOverActive; // TODO - see if there's a way of doing this via rxjs\n\n      overlapsChanged$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n        dragOverActive = true;\n        addClass(this.renderer, this.element, this.dragOverClass);\n\n        if (this.dragEnter.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragEnter.next(currentDragEvent);\n          });\n        }\n      });\n      overlaps$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n        if (this.dragOver.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragOver.next(currentDragEvent);\n          });\n        }\n      });\n      overlapsChanged$.pipe(pairwise(), filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)).subscribe(() => {\n        dragOverActive = false;\n        removeClass(this.renderer, this.element, this.dragOverClass);\n\n        if (this.dragLeave.observers.length > 0) {\n          this.zone.run(() => {\n            this.dragLeave.next(currentDragEvent);\n          });\n        }\n      });\n      drag$.subscribe({\n        complete: () => {\n          deregisterScrollListener();\n          removeClass(this.renderer, this.element, this.dragActiveClass);\n\n          if (dragOverActive) {\n            removeClass(this.renderer, this.element, this.dragOverClass);\n\n            if (this.drop.observers.length > 0) {\n              this.zone.run(() => {\n                this.drop.next(currentDragEvent);\n              });\n            }\n          }\n        }\n      });\n    });\n  }\n\n  ngOnDestroy() {\n    if (this.currentDragSubscription) {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }\n\n}\n\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n  return new (t || DroppableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DraggableHelper), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n};\n\nDroppableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DroppableDirective,\n  selectors: [[\"\", \"mwlDroppable\", \"\"]],\n  inputs: {\n    dragOverClass: \"dragOverClass\",\n    dragActiveClass: \"dragActiveClass\",\n    validateDrop: \"validateDrop\"\n  },\n  outputs: {\n    dragEnter: \"dragEnter\",\n    dragLeave: \"dragLeave\",\n    dragOver: \"dragOver\",\n    drop: \"drop\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DroppableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDroppable]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: DraggableHelper\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    dragOverClass: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    validateDrop: [{\n      type: Input\n    }],\n    dragEnter: [{\n      type: Output\n    }],\n    dragLeave: [{\n      type: Output\n    }],\n    dragOver: [{\n      type: Output\n    }],\n    drop: [{\n      type: Output\n    }]\n  });\n})();\n\nclass DragAndDropModule {}\n\nDragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) {\n  return new (t || DragAndDropModule)();\n};\n\nDragAndDropModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: DragAndDropModule\n});\nDragAndDropModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DragAndDropModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n      exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of angular-draggable-droppable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DragAndDropModule, DraggableDirective, DraggableScrollContainerDirective, DroppableDirective };","map":{"version":3,"names":["i0","Injectable","Directive","EventEmitter","Optional","Inject","Input","Output","NgModule","Subject","Observable","ReplaySubject","merge","combineLatest","fromEvent","filter","mergeMap","startWith","map","share","takeUntil","take","takeLast","count","pairwise","distinctUntilChanged","DOCUMENT","autoScroll","addClass","renderer","element","classToAdd","split","forEach","className","nativeElement","removeClass","classToRemove","DraggableHelper","constructor","currentDrag","ɵfac","ɵprov","type","args","providedIn","DraggableScrollContainerDirective","elementRef","ElementRef","ɵdir","selector","DraggableDirective","draggableHelper","zone","vcr","scrollContainer","document","dragAxis","x","y","dragSnapGrid","ghostDragEnabled","showOriginalElementWhileDragging","dragCursor","margin","dragPointerDown","dragStart","ghostElementCreated","dragging","dragEnd","pointerDown$","pointerMove$","pointerUp$","eventListenerSubscriptions","destroy$","timeLongPress","timerBegin","timerEnd","ngOnInit","checkEventListeners","pointerDragged$","pipe","canDrag","pointerDownEvent","event","stopPropagation","globalDragStyle","createElement","setAttribute","appendChild","createText","requestAnimationFrame","head","startScrollPosition","getScrollPosition","scrollContainerScroll$","observer","listen","e","next","currentDrag$","cancelDrag$","observers","length","run","dragComplete$","pointerMove","pointerMoveEvent","scroll","transformX","clientX","transformY","clientY","scrollLeft","left","scrollTop","top","target","moveData","Math","round","scrollX","scrollY","Object","assign","validateDrag","transform","dragStarted$","dragEnded$","subscribe","scroller","defaultView","dragActiveClass","rect","getBoundingClientRect","clone","cloneNode","setStyle","ghostElementAppendTo","parentNode","insertBefore","nextSibling","ghostElement","body","style","cursor","setElementStyles","position","width","height","willChange","pointerEvents","ghostElementTemplate","viewRef","createEmbeddedView","innerHTML","rootNodes","node","Node","remove","indexOf","emit","parentElement","removeChild","dragEndData","dragEndData$","calledCount","dragCancelled","complete","destroy","value","previous","dropData","ngOnChanges","changes","ngOnDestroy","unsubscribeEventListeners","hasEventListeners","keys","runOutsideAngular","mousedown","onMouseDown","mouseup","onMouseUp","touchstart","onTouchStart","touchend","onTouchEnd","touchcancel","mouseenter","onMouseEnter","mouseleave","onMouseLeave","button","mousemove","mouseMoveEvent","isDragActivated","hasContainerScrollbar","touchStartLongPress","Date","now","hasScrollbar","touchmove","contextMenuListener","preventDefault","touchMoveListener","passive","touchMoveEvent","shouldBeginDrag","targetTouches","unsubscribe","touches","enableScroll","changedTouches","setCursor","styles","key","getScrollElement","window","pageYOffset","documentElement","pageXOffset","moveScrollPosition","deltaScroll","abs","deltaX","deltaY","deltaTotal","longPressConfig","delta","duration","delay","disableScroll","containerHasHorizontalScroll","scrollWidth","clientWidth","containerHasVerticalScroll","scrollHeight","clientHeight","Renderer2","NgZone","ViewContainerRef","decorators","undefined","isCoordinateWithinRectangle","right","bottom","DroppableDirective","dragEnter","dragLeave","dragOver","drop","currentDragSubscription","drag$","droppableElement","updateCache","deregisterScrollListener","currentDragEvent","overlaps$","scrollContainerRect","isWithinElement","isDropAllowed","validateDrop","overlapsChanged$","dragOverActive","overlapsNow","dragOverClass","didOverlap","DragAndDropModule","ɵmod","ɵinj","declarations","exports"],"sources":["E:/Svendeproeve/solution/Calendar/ClientApp/node_modules/angular-draggable-droppable/fesm2015/angular-draggable-droppable.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Directive, EventEmitter, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport { Subject, Observable, ReplaySubject, merge, combineLatest, fromEvent } from 'rxjs';\nimport { filter, mergeMap, startWith, map, share, takeUntil, take, takeLast, count, pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\n\nfunction addClass(renderer, element, classToAdd) {\n    if (classToAdd) {\n        classToAdd\n            .split(' ')\n            .forEach((className) => renderer.addClass(element.nativeElement, className));\n    }\n}\nfunction removeClass(renderer, element, classToRemove) {\n    if (classToRemove) {\n        classToRemove\n            .split(' ')\n            .forEach((className) => renderer.removeClass(element.nativeElement, className));\n    }\n}\n\nclass DraggableHelper {\n    constructor() {\n        this.currentDrag = new Subject();\n    }\n}\nDraggableHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableHelper, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nDraggableHelper.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableHelper, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableHelper, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }] });\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\nclass DraggableScrollContainerDirective {\n    /**\n     * @hidden\n     */\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n    }\n}\nDraggableScrollContainerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableScrollContainerDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\nDraggableScrollContainerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.1.0\", type: DraggableScrollContainerDirective, selector: \"[mwlDraggableScrollContainer]\", ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableScrollContainerDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDraggableScrollContainer]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n\nclass DraggableDirective {\n    /**\n     * @hidden\n     */\n    constructor(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n        this.element = element;\n        this.renderer = renderer;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.vcr = vcr;\n        this.scrollContainer = scrollContainer;\n        this.document = document;\n        /**\n         * The axis along which the element is draggable\n         */\n        this.dragAxis = { x: true, y: true };\n        /**\n         * Snap all drags to an x / y grid\n         */\n        this.dragSnapGrid = {};\n        /**\n         * Show a ghost element that shows the drag when dragging\n         */\n        this.ghostDragEnabled = true;\n        /**\n         * Show the original element when ghostDragEnabled is true\n         */\n        this.showOriginalElementWhileDragging = false;\n        /**\n         * The cursor to use when hovering over a draggable element\n         */\n        this.dragCursor = '';\n        /*\n         * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n         */\n        this.autoScroll = {\n            margin: 20,\n        };\n        /**\n         * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n         */\n        this.dragPointerDown = new EventEmitter();\n        /**\n         * Called when the element has started to be dragged.\n         * Only called after at least one mouse or touch move event.\n         * If you call $event.cancelDrag$.emit() it will cancel the current drag\n         */\n        this.dragStart = new EventEmitter();\n        /**\n         * Called after the ghost element has been created\n         */\n        this.ghostElementCreated = new EventEmitter();\n        /**\n         * Called when the element is being dragged\n         */\n        this.dragging = new EventEmitter();\n        /**\n         * Called after the element is dragged\n         */\n        this.dragEnd = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.pointerDown$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerMove$ = new Subject();\n        /**\n         * @hidden\n         */\n        this.pointerUp$ = new Subject();\n        this.eventListenerSubscriptions = {};\n        this.destroy$ = new Subject();\n        this.timeLongPress = { timerBegin: 0, timerEnd: 0 };\n    }\n    ngOnInit() {\n        this.checkEventListeners();\n        const pointerDragged$ = this.pointerDown$.pipe(filter(() => this.canDrag()), mergeMap((pointerDownEvent) => {\n            // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n            // stop mouse events propagating up the chain\n            if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n                pointerDownEvent.event.stopPropagation();\n            }\n            // hack to prevent text getting selected in safari while dragging\n            const globalDragStyle = this.renderer.createElement('style');\n            this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n            this.renderer.appendChild(globalDragStyle, this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `));\n            requestAnimationFrame(() => {\n                this.document.head.appendChild(globalDragStyle);\n            });\n            const startScrollPosition = this.getScrollPosition();\n            const scrollContainerScroll$ = new Observable((observer) => {\n                const scrollContainer = this.scrollContainer\n                    ? this.scrollContainer.elementRef.nativeElement\n                    : 'window';\n                return this.renderer.listen(scrollContainer, 'scroll', (e) => observer.next(e));\n            }).pipe(startWith(startScrollPosition), map(() => this.getScrollPosition()));\n            const currentDrag$ = new Subject();\n            const cancelDrag$ = new ReplaySubject();\n            if (this.dragPointerDown.observers.length > 0) {\n                this.zone.run(() => {\n                    this.dragPointerDown.next({ x: 0, y: 0 });\n                });\n            }\n            const dragComplete$ = merge(this.pointerUp$, this.pointerDown$, cancelDrag$, this.destroy$).pipe(share());\n            const pointerMove = combineLatest([\n                this.pointerMove$,\n                scrollContainerScroll$,\n            ]).pipe(map(([pointerMoveEvent, scroll]) => {\n                return {\n                    currentDrag$,\n                    transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n                    transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n                    clientX: pointerMoveEvent.clientX,\n                    clientY: pointerMoveEvent.clientY,\n                    scrollLeft: scroll.left,\n                    scrollTop: scroll.top,\n                    target: pointerMoveEvent.event.target,\n                };\n            }), map((moveData) => {\n                if (this.dragSnapGrid.x) {\n                    moveData.transformX =\n                        Math.round(moveData.transformX / this.dragSnapGrid.x) *\n                            this.dragSnapGrid.x;\n                }\n                if (this.dragSnapGrid.y) {\n                    moveData.transformY =\n                        Math.round(moveData.transformY / this.dragSnapGrid.y) *\n                            this.dragSnapGrid.y;\n                }\n                return moveData;\n            }), map((moveData) => {\n                if (!this.dragAxis.x) {\n                    moveData.transformX = 0;\n                }\n                if (!this.dragAxis.y) {\n                    moveData.transformY = 0;\n                }\n                return moveData;\n            }), map((moveData) => {\n                const scrollX = moveData.scrollLeft - startScrollPosition.left;\n                const scrollY = moveData.scrollTop - startScrollPosition.top;\n                return Object.assign(Object.assign({}, moveData), { x: moveData.transformX + scrollX, y: moveData.transformY + scrollY });\n            }), filter(({ x, y, transformX, transformY }) => !this.validateDrag ||\n                this.validateDrag({\n                    x,\n                    y,\n                    transform: { x: transformX, y: transformY },\n                })), takeUntil(dragComplete$), share());\n            const dragStarted$ = pointerMove.pipe(take(1), share());\n            const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n            dragStarted$.subscribe(({ clientX, clientY, x, y }) => {\n                if (this.dragStart.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragStart.next({ cancelDrag$ });\n                    });\n                }\n                this.scroller = autoScroll([\n                    this.scrollContainer\n                        ? this.scrollContainer.elementRef.nativeElement\n                        : this.document.defaultView,\n                ], Object.assign(Object.assign({}, this.autoScroll), { autoScroll() {\n                        return true;\n                    } }));\n                addClass(this.renderer, this.element, this.dragActiveClass);\n                if (this.ghostDragEnabled) {\n                    const rect = this.element.nativeElement.getBoundingClientRect();\n                    const clone = this.element.nativeElement.cloneNode(true);\n                    if (!this.showOriginalElementWhileDragging) {\n                        this.renderer.setStyle(this.element.nativeElement, 'visibility', 'hidden');\n                    }\n                    if (this.ghostElementAppendTo) {\n                        this.ghostElementAppendTo.appendChild(clone);\n                    }\n                    else {\n                        this.element.nativeElement.parentNode.insertBefore(clone, this.element.nativeElement.nextSibling);\n                    }\n                    this.ghostElement = clone;\n                    this.document.body.style.cursor = this.dragCursor;\n                    this.setElementStyles(clone, {\n                        position: 'fixed',\n                        top: `${rect.top}px`,\n                        left: `${rect.left}px`,\n                        width: `${rect.width}px`,\n                        height: `${rect.height}px`,\n                        cursor: this.dragCursor,\n                        margin: '0',\n                        willChange: 'transform',\n                        pointerEvents: 'none',\n                    });\n                    if (this.ghostElementTemplate) {\n                        const viewRef = this.vcr.createEmbeddedView(this.ghostElementTemplate);\n                        clone.innerHTML = '';\n                        viewRef.rootNodes\n                            .filter((node) => node instanceof Node)\n                            .forEach((node) => {\n                            clone.appendChild(node);\n                        });\n                        dragEnded$.subscribe(() => {\n                            this.vcr.remove(this.vcr.indexOf(viewRef));\n                        });\n                    }\n                    if (this.ghostElementCreated.observers.length > 0) {\n                        this.zone.run(() => {\n                            this.ghostElementCreated.emit({\n                                clientX: clientX - x,\n                                clientY: clientY - y,\n                                element: clone,\n                            });\n                        });\n                    }\n                    dragEnded$.subscribe(() => {\n                        clone.parentElement.removeChild(clone);\n                        this.ghostElement = null;\n                        this.renderer.setStyle(this.element.nativeElement, 'visibility', '');\n                    });\n                }\n                this.draggableHelper.currentDrag.next(currentDrag$);\n            });\n            dragEnded$\n                .pipe(mergeMap((dragEndData) => {\n                const dragEndData$ = cancelDrag$.pipe(count(), take(1), map((calledCount) => (Object.assign(Object.assign({}, dragEndData), { dragCancelled: calledCount > 0 }))));\n                cancelDrag$.complete();\n                return dragEndData$;\n            }))\n                .subscribe(({ x, y, dragCancelled }) => {\n                this.scroller.destroy();\n                if (this.dragEnd.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragEnd.next({ x, y, dragCancelled });\n                    });\n                }\n                removeClass(this.renderer, this.element, this.dragActiveClass);\n                currentDrag$.complete();\n            });\n            merge(dragComplete$, dragEnded$)\n                .pipe(take(1))\n                .subscribe(() => {\n                requestAnimationFrame(() => {\n                    this.document.head.removeChild(globalDragStyle);\n                });\n            });\n            return pointerMove;\n        }), share());\n        merge(pointerDragged$.pipe(take(1), map((value) => [, value])), pointerDragged$.pipe(pairwise()))\n            .pipe(filter(([previous, next]) => {\n            if (!previous) {\n                return true;\n            }\n            return previous.x !== next.x || previous.y !== next.y;\n        }), map(([previous, next]) => next))\n            .subscribe(({ x, y, currentDrag$, clientX, clientY, transformX, transformY, target, }) => {\n            if (this.dragging.observers.length > 0) {\n                this.zone.run(() => {\n                    this.dragging.next({ x, y });\n                });\n            }\n            requestAnimationFrame(() => {\n                if (this.ghostElement) {\n                    const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n                    this.setElementStyles(this.ghostElement, {\n                        transform,\n                        '-webkit-transform': transform,\n                        '-ms-transform': transform,\n                        '-moz-transform': transform,\n                        '-o-transform': transform,\n                    });\n                }\n            });\n            currentDrag$.next({\n                clientX,\n                clientY,\n                dropData: this.dropData,\n                target,\n            });\n        });\n    }\n    ngOnChanges(changes) {\n        if (changes.dragAxis) {\n            this.checkEventListeners();\n        }\n    }\n    ngOnDestroy() {\n        this.unsubscribeEventListeners();\n        this.pointerDown$.complete();\n        this.pointerMove$.complete();\n        this.pointerUp$.complete();\n        this.destroy$.next();\n    }\n    checkEventListeners() {\n        const canDrag = this.canDrag();\n        const hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n        if (canDrag && !hasEventListeners) {\n            this.zone.runOutsideAngular(() => {\n                this.eventListenerSubscriptions.mousedown = this.renderer.listen(this.element.nativeElement, 'mousedown', (event) => {\n                    this.onMouseDown(event);\n                });\n                this.eventListenerSubscriptions.mouseup = this.renderer.listen('document', 'mouseup', (event) => {\n                    this.onMouseUp(event);\n                });\n                this.eventListenerSubscriptions.touchstart = this.renderer.listen(this.element.nativeElement, 'touchstart', (event) => {\n                    this.onTouchStart(event);\n                });\n                this.eventListenerSubscriptions.touchend = this.renderer.listen('document', 'touchend', (event) => {\n                    this.onTouchEnd(event);\n                });\n                this.eventListenerSubscriptions.touchcancel = this.renderer.listen('document', 'touchcancel', (event) => {\n                    this.onTouchEnd(event);\n                });\n                this.eventListenerSubscriptions.mouseenter = this.renderer.listen(this.element.nativeElement, 'mouseenter', () => {\n                    this.onMouseEnter();\n                });\n                this.eventListenerSubscriptions.mouseleave = this.renderer.listen(this.element.nativeElement, 'mouseleave', () => {\n                    this.onMouseLeave();\n                });\n            });\n        }\n        else if (!canDrag && hasEventListeners) {\n            this.unsubscribeEventListeners();\n        }\n    }\n    onMouseDown(event) {\n        if (event.button === 0) {\n            if (!this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', (mouseMoveEvent) => {\n                    this.pointerMove$.next({\n                        event: mouseMoveEvent,\n                        clientX: mouseMoveEvent.clientX,\n                        clientY: mouseMoveEvent.clientY,\n                    });\n                });\n            }\n            this.pointerDown$.next({\n                event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    }\n    onMouseUp(event) {\n        if (event.button === 0) {\n            if (this.eventListenerSubscriptions.mousemove) {\n                this.eventListenerSubscriptions.mousemove();\n                delete this.eventListenerSubscriptions.mousemove;\n            }\n            this.pointerUp$.next({\n                event,\n                clientX: event.clientX,\n                clientY: event.clientY,\n            });\n        }\n    }\n    onTouchStart(event) {\n        let startScrollPosition;\n        let isDragActivated;\n        let hasContainerScrollbar;\n        if (this.touchStartLongPress) {\n            this.timeLongPress.timerBegin = Date.now();\n            isDragActivated = false;\n            hasContainerScrollbar = this.hasScrollbar();\n            startScrollPosition = this.getScrollPosition();\n        }\n        if (!this.eventListenerSubscriptions.touchmove) {\n            const contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe((e) => {\n                e.preventDefault();\n            });\n            const touchMoveListener = fromEvent(this.document, 'touchmove', {\n                passive: false,\n            }).subscribe((touchMoveEvent) => {\n                if (this.touchStartLongPress &&\n                    !isDragActivated &&\n                    hasContainerScrollbar) {\n                    isDragActivated = this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n                }\n                if (!this.touchStartLongPress ||\n                    !hasContainerScrollbar ||\n                    isDragActivated) {\n                    touchMoveEvent.preventDefault();\n                    this.pointerMove$.next({\n                        event: touchMoveEvent,\n                        clientX: touchMoveEvent.targetTouches[0].clientX,\n                        clientY: touchMoveEvent.targetTouches[0].clientY,\n                    });\n                }\n            });\n            this.eventListenerSubscriptions.touchmove = () => {\n                contextMenuListener.unsubscribe();\n                touchMoveListener.unsubscribe();\n            };\n        }\n        this.pointerDown$.next({\n            event,\n            clientX: event.touches[0].clientX,\n            clientY: event.touches[0].clientY,\n        });\n    }\n    onTouchEnd(event) {\n        if (this.eventListenerSubscriptions.touchmove) {\n            this.eventListenerSubscriptions.touchmove();\n            delete this.eventListenerSubscriptions.touchmove;\n            if (this.touchStartLongPress) {\n                this.enableScroll();\n            }\n        }\n        this.pointerUp$.next({\n            event,\n            clientX: event.changedTouches[0].clientX,\n            clientY: event.changedTouches[0].clientY,\n        });\n    }\n    onMouseEnter() {\n        this.setCursor(this.dragCursor);\n    }\n    onMouseLeave() {\n        this.setCursor('');\n    }\n    canDrag() {\n        return this.dragAxis.x || this.dragAxis.y;\n    }\n    setCursor(value) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n            this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n        }\n    }\n    unsubscribeEventListeners() {\n        Object.keys(this.eventListenerSubscriptions).forEach((type) => {\n            this.eventListenerSubscriptions[type]();\n            delete this.eventListenerSubscriptions[type];\n        });\n    }\n    setElementStyles(element, styles) {\n        Object.keys(styles).forEach((key) => {\n            this.renderer.setStyle(element, key, styles[key]);\n        });\n    }\n    getScrollElement() {\n        if (this.scrollContainer) {\n            return this.scrollContainer.elementRef.nativeElement;\n        }\n        else {\n            return this.document.body;\n        }\n    }\n    getScrollPosition() {\n        if (this.scrollContainer) {\n            return {\n                top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n                left: this.scrollContainer.elementRef.nativeElement.scrollLeft,\n            };\n        }\n        else {\n            return {\n                top: window.pageYOffset || this.document.documentElement.scrollTop,\n                left: window.pageXOffset || this.document.documentElement.scrollLeft,\n            };\n        }\n    }\n    shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n        const moveScrollPosition = this.getScrollPosition();\n        const deltaScroll = {\n            top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n            left: Math.abs(moveScrollPosition.left - startScrollPosition.left),\n        };\n        const deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n        const deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n        const deltaTotal = deltaX + deltaY;\n        const longPressConfig = this.touchStartLongPress;\n        if (deltaTotal > longPressConfig.delta ||\n            deltaScroll.top > 0 ||\n            deltaScroll.left > 0) {\n            this.timeLongPress.timerBegin = Date.now();\n        }\n        this.timeLongPress.timerEnd = Date.now();\n        const duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n        if (duration >= longPressConfig.delay) {\n            this.disableScroll();\n            return true;\n        }\n        return false;\n    }\n    enableScroll() {\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', '');\n    }\n    disableScroll() {\n        /* istanbul ignore next */\n        if (this.scrollContainer) {\n            this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n        }\n        this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n    }\n    hasScrollbar() {\n        const scrollContainer = this.getScrollElement();\n        const containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n        const containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n        return containerHasHorizontalScroll || containerHasVerticalScroll;\n    }\n}\nDraggableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: DraggableHelper }, { token: i0.NgZone }, { token: i0.ViewContainerRef }, { token: DraggableScrollContainerDirective, optional: true }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });\nDraggableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.1.0\", type: DraggableDirective, selector: \"[mwlDraggable]\", inputs: { dropData: \"dropData\", dragAxis: \"dragAxis\", dragSnapGrid: \"dragSnapGrid\", ghostDragEnabled: \"ghostDragEnabled\", showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\", validateDrag: \"validateDrag\", dragCursor: \"dragCursor\", dragActiveClass: \"dragActiveClass\", ghostElementAppendTo: \"ghostElementAppendTo\", ghostElementTemplate: \"ghostElementTemplate\", touchStartLongPress: \"touchStartLongPress\", autoScroll: \"autoScroll\" }, outputs: { dragPointerDown: \"dragPointerDown\", dragStart: \"dragStart\", ghostElementCreated: \"ghostElementCreated\", dragging: \"dragging\", dragEnd: \"dragEnd\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DraggableDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDraggable]',\n                }]\n        }], ctorParameters: function () {\n        return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DraggableHelper }, { type: i0.NgZone }, { type: i0.ViewContainerRef }, { type: DraggableScrollContainerDirective, decorators: [{\n                        type: Optional\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [DOCUMENT]\n                    }] }];\n    }, propDecorators: { dropData: [{\n                type: Input\n            }], dragAxis: [{\n                type: Input\n            }], dragSnapGrid: [{\n                type: Input\n            }], ghostDragEnabled: [{\n                type: Input\n            }], showOriginalElementWhileDragging: [{\n                type: Input\n            }], validateDrag: [{\n                type: Input\n            }], dragCursor: [{\n                type: Input\n            }], dragActiveClass: [{\n                type: Input\n            }], ghostElementAppendTo: [{\n                type: Input\n            }], ghostElementTemplate: [{\n                type: Input\n            }], touchStartLongPress: [{\n                type: Input\n            }], autoScroll: [{\n                type: Input\n            }], dragPointerDown: [{\n                type: Output\n            }], dragStart: [{\n                type: Output\n            }], ghostElementCreated: [{\n                type: Output\n            }], dragging: [{\n                type: Output\n            }], dragEnd: [{\n                type: Output\n            }] } });\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n    return (clientX >= rect.left &&\n        clientX <= rect.right &&\n        clientY >= rect.top &&\n        clientY <= rect.bottom);\n}\nclass DroppableDirective {\n    constructor(element, draggableHelper, zone, renderer, scrollContainer) {\n        this.element = element;\n        this.draggableHelper = draggableHelper;\n        this.zone = zone;\n        this.renderer = renderer;\n        this.scrollContainer = scrollContainer;\n        /**\n         * Called when a draggable element starts overlapping the element\n         */\n        this.dragEnter = new EventEmitter();\n        /**\n         * Called when a draggable element stops overlapping the element\n         */\n        this.dragLeave = new EventEmitter();\n        /**\n         * Called when a draggable element is moved over the element\n         */\n        this.dragOver = new EventEmitter();\n        /**\n         * Called when a draggable element is dropped on this element\n         */\n        this.drop = new EventEmitter(); // eslint-disable-line  @angular-eslint/no-output-native\n    }\n    ngOnInit() {\n        this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe((drag$) => {\n            addClass(this.renderer, this.element, this.dragActiveClass);\n            const droppableElement = {\n                updateCache: true,\n            };\n            const deregisterScrollListener = this.renderer.listen(this.scrollContainer\n                ? this.scrollContainer.elementRef.nativeElement\n                : 'window', 'scroll', () => {\n                droppableElement.updateCache = true;\n            });\n            let currentDragEvent;\n            const overlaps$ = drag$.pipe(map(({ clientX, clientY, dropData, target }) => {\n                currentDragEvent = { clientX, clientY, dropData, target };\n                if (droppableElement.updateCache) {\n                    droppableElement.rect =\n                        this.element.nativeElement.getBoundingClientRect();\n                    if (this.scrollContainer) {\n                        droppableElement.scrollContainerRect =\n                            this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n                    }\n                    droppableElement.updateCache = false;\n                }\n                const isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);\n                const isDropAllowed = !this.validateDrop ||\n                    this.validateDrop({ clientX, clientY, target, dropData });\n                if (droppableElement.scrollContainerRect) {\n                    return (isWithinElement &&\n                        isDropAllowed &&\n                        isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect));\n                }\n                else {\n                    return isWithinElement && isDropAllowed;\n                }\n            }));\n            const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n            let dragOverActive; // TODO - see if there's a way of doing this via rxjs\n            overlapsChanged$\n                .pipe(filter((overlapsNow) => overlapsNow))\n                .subscribe(() => {\n                dragOverActive = true;\n                addClass(this.renderer, this.element, this.dragOverClass);\n                if (this.dragEnter.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragEnter.next(currentDragEvent);\n                    });\n                }\n            });\n            overlaps$.pipe(filter((overlapsNow) => overlapsNow)).subscribe(() => {\n                if (this.dragOver.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragOver.next(currentDragEvent);\n                    });\n                }\n            });\n            overlapsChanged$\n                .pipe(pairwise(), filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow))\n                .subscribe(() => {\n                dragOverActive = false;\n                removeClass(this.renderer, this.element, this.dragOverClass);\n                if (this.dragLeave.observers.length > 0) {\n                    this.zone.run(() => {\n                        this.dragLeave.next(currentDragEvent);\n                    });\n                }\n            });\n            drag$.subscribe({\n                complete: () => {\n                    deregisterScrollListener();\n                    removeClass(this.renderer, this.element, this.dragActiveClass);\n                    if (dragOverActive) {\n                        removeClass(this.renderer, this.element, this.dragOverClass);\n                        if (this.drop.observers.length > 0) {\n                            this.zone.run(() => {\n                                this.drop.next(currentDragEvent);\n                            });\n                        }\n                    }\n                },\n            });\n        });\n    }\n    ngOnDestroy() {\n        if (this.currentDragSubscription) {\n            this.currentDragSubscription.unsubscribe();\n        }\n    }\n}\nDroppableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DroppableDirective, deps: [{ token: i0.ElementRef }, { token: DraggableHelper }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: DraggableScrollContainerDirective, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\nDroppableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.1.0\", type: DroppableDirective, selector: \"[mwlDroppable]\", inputs: { dragOverClass: \"dragOverClass\", dragActiveClass: \"dragActiveClass\", validateDrop: \"validateDrop\" }, outputs: { dragEnter: \"dragEnter\", dragLeave: \"dragLeave\", dragOver: \"dragOver\", drop: \"drop\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DroppableDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mwlDroppable]',\n                }]\n        }], ctorParameters: function () {\n        return [{ type: i0.ElementRef }, { type: DraggableHelper }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: DraggableScrollContainerDirective, decorators: [{\n                        type: Optional\n                    }] }];\n    }, propDecorators: { dragOverClass: [{\n                type: Input\n            }], dragActiveClass: [{\n                type: Input\n            }], validateDrop: [{\n                type: Input\n            }], dragEnter: [{\n                type: Output\n            }], dragLeave: [{\n                type: Output\n            }], dragOver: [{\n                type: Output\n            }], drop: [{\n                type: Output\n            }] } });\n\nclass DragAndDropModule {\n}\nDragAndDropModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DragAndDropModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nDragAndDropModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.1.0\", ngImport: i0, type: DragAndDropModule, declarations: [DraggableDirective,\n        DroppableDirective,\n        DraggableScrollContainerDirective], exports: [DraggableDirective,\n        DroppableDirective,\n        DraggableScrollContainerDirective] });\nDragAndDropModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DragAndDropModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DragAndDropModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [\n                        DraggableDirective,\n                        DroppableDirective,\n                        DraggableScrollContainerDirective,\n                    ],\n                    exports: [\n                        DraggableDirective,\n                        DroppableDirective,\n                        DraggableScrollContainerDirective,\n                    ],\n                }]\n        }] });\n\n/*\n * Public API Surface of angular-draggable-droppable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DragAndDropModule, DraggableDirective, DraggableScrollContainerDirective, DroppableDirective };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}